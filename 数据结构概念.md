## 数据结构概念

* 数据结构方便计算机管理数据，是计算机用来存储、组织数据的方式，以及定义了一些列的操作。

## 线性表
* 顺序表：顺序存储，通过数组来实现。
* 链表：链式存储。

### 练习1：动态数组

- 动态数组需要知道：数组首地址、元素个数、元素类型、数组容量。通过viod*可以实现指向任意元素的地址，来保存任意元素。

	```
	struct DynamicArray
	{
		//数组存储元素的空间的首地址
		void **addr;
		//存储数据的内存中最大能够容纳多少元素
		int capacity; //容量
		//当前存储数据的内存中有多少个元素
		int size; //大小
	};
	```
	这里的void ** addr说明：这里是一个二级指针，指向一个void * 的指针，void* 就是我们要保持的数据类型，而指针等价于数组的首地址。内存模型如下图。
	![动态数组首地址内存模型.png](https://i.loli.net/2019/10/30/yPdwVA8MxQ7ojLp.png)
- 在动态数组上面的操作上面的操作：
	1. 初始化函数：struct DynamicArray* init_dynamic_array(int capacity) 返回值是struct DynamicArray*，一个指针类型，原因是这个函数会生成一个DynamicArray结构体，让调用者拿到指针可以直接指向原来开辟的结构体空间。返回结构体指针和结构体的区别如下图。
	![函数返回结构体指针和结构体区别.png](https://i.loli.net/2019/10/30/bNRHmteUG87xijq.png)
	返回指针指向的是同一块内存，即同一个结构体，返回结构体的会产生拷贝，结构体A是函数产生的，结构体B是myArr，他们不在同一块内存，当然调用完成后结构体A局部变量会被销毁，但是拷贝复值动作会多消耗系统资源。
	2. 遍历元素：void foreach\_dynamic\_array(struct DymicArray\* arr, void (\* \_callback) (void \*)) 这里的\_callback是函数指针，到时候需要调用者传递一个返回值为void，参数为void\*的函数，这样做的原因是动态数组保存的是void\*类型的数据，设计者不知道调用者会具体保存说明类型，故无法直接处理，只能留一个函数指针参数，到时候让调用者去实现。
	3. 插入元素：void insert\_dynamic\_array(DynamicArray\* arr, int pos, void\* elem)
	4. 删除元素(通过位置)：void remove\_by\_pos(DynamicArray\* arr, int pos)
	5. 删除元素（通过值）: int remove\_by\_value(DaynamicArray\* arr, void\* data, int (\* compare)(void\* , void\*));
	6. 销毁函数：delete\_dynamic\_array(DynamicArray\* arr)
- 分文件定义
	1. 头文件，只定义数据结构和声明函数原型。
	
	```
		#pragma one // 防止重复包含
		#ifdef __cplusplus
		extern "C"{
		#endif
		// 这里放入结构体和函数声明
		#ifdef __cplusplus
		}
		#endif
		
	```
	
	2. 实现问题，具体函数实现
		
### 练习2: 单链表（版本一）
- 两个结构体：单链表节点结构体保存数据域和指针域，单链表结构体保存头节点和大小等其他信息（如尾指针）
- 定义在上面的操作：
	1. 初始化链表 LinkList Init_LinkList(int size);
	2. 插入元素 void Insert_LinkList(LinkList L, int pos, void* data);
	3. 遍历 Foreach_LinkList(LinkList L, visit vis);
